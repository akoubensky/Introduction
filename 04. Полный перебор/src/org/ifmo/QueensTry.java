package org.ifmo;

/**
 * Поиск правильных расстановок ферзей на шахматной доске произвольного размера.
 * Расстановка ферзей на поля квадратной шакматной доски считается правильной,
 * если никакие два ферзя не находятся на одной горизонтали, на одной вертикали
 * или на одной диагонали (ферзи "не бьют друг друга").
 * В данном классе алгоритм использует новую исключительную ситуацию.
 */
public class QueensTry {
	/**
	 * Исключительная ситуация, возникающая, когда правильная расстановка
	 * ферзей найдена.
	 */
	private static class FoundException extends Exception {
		// Представление позиции расставленных ферзей: массив целых чисел,
		// каждое из которых задает номер клетки в данной горизонтали,
		// на которой стоит (единственный на горизонтали) ферзь.
		private int[] position = null;

		// Конструктор, в котором запоминается расстановка ферзей.
		public FoundException(int[] position) {
			this.position = position;
		}
		
		// Доступ к позиции
		public int[] position() { return position; }
	}

	/**
	 * Основная функция поиска правильной расстановки обращается
	 * к вспомогательной рекурсивной функции, которая и выполняет
	 * всю основную работу.
	 * @param n Размер доски и число ферзей, подлежащих расстановке.
	 */
	public static void queens(int n) {
		try {
			queens(new int[n], 0);
		} catch (FoundException found) {
			System.out.println("Найдена правильная расстановка:");
			printPosition(found.position());
			return;
		}
		System.out.println("Расстановка невозможна");
	}

	/**
	 * Рекурсивная функция поиска правильной расстановки ферзей.
	 * Считает, что несколько ферзей уже расставлены и пытается в
	 * этих условиях найти расстановку остальных ферзей.
	 * @param board Массив, представляющий позицию ферзей.
	 * @param fixed Число уже расставленных ферзей.
	 * @return
	 */
	private static void queens(int[] board, int fixed) throws FoundException {
		int n = board.length;
		if (fixed == n) {
			// Все ферзи уже расставлены!
			throw new FoundException(board);
		}
		// Пытаемся на горизонталь с номером fixed поставить очередного
		// ферзя. Проверка возможности установки ферзя в определенную
		// позицию осуществляется функцией valid.
		for (int i = 0; i < n; ++i) {
			if (valid(board, fixed, i)) {
				board[fixed] = i;
				// Очередной ферзь установлен в легальную позицию.
				queens(board, fixed + 1);
			}
		}
	}

	/**
	 * Функция проверки возможности поставить ферзя в заданную позицию.
	 * @param board Позиция, содержащая уже несколько правильно стоящих ферзей.
	 * @param fixed Число поставленных ферзей.
	 * @param pos Номер клетки, в которую мы пытаемся поставить очередного ферзя.
	 * @return True, если ферзя можно поставить на горизонталь fixed в клетку
	 *     с номером pos, False, если нельзя.
	 */
	private static boolean valid(int[] board, int fixed, int pos) {
		// Для каждого из уже поставленных ферзей проверяем, не находится ли
		// он на одной вертикали или одной диагонали с новым.
		for (int i = 0; i < fixed; ++i) {
			if (pos == board[i] || fixed - i == Math.abs(pos - board[i])) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Функция печати найденной позиции "рисует" квадратную доску,
	 * отмечая в каждой горизонтали поставленного ферзя звездочкой.
	 * Пустые клетки обозначаются точкой.
	 * @param pos Массив, представляющий позицию.
	 */
	private static void printPosition(int[] pos) {
		int n = pos.length;
		for (int row : pos) {
			for (int i = 0; i < row; ++i) System.out.print(" .");
			System.out.print(" *");
			for (int i = row+1; i < n; ++i) System.out.print(" .");
			System.out.println();
		}
	}
	/**
	 * Тестовая функция осуществляет поиск правильной расстановки на
	 * "классической" шахматной доске размером 8х8 клеток.
	 * @param args Не используется.
	 */
	public static void main(String[] args) {
		queens(8);
	}
}
